using UnityEngine;
using System.Collections;

/**
 * 
 * 
 */
public class StoneCamera : MonoBehaviour {

	public Transform target;
	private Vector3 cameraVelocity = Vector3.zero;
	private Vector3 idealSpherical = Vector3.zero;
	public float springK = 1;
	public float dampingK = 1;
	public float cameraHeight = 3;
	
	// Use this for initialization
	void Start () {
	
	}
	
	// Update is called once per frame
	void Update () {
		float time = Time.deltaTime;
		Vector3 position = transform.position;
		 
		// update the ideal azimuth based on the camera's current
		// position with respect to the target
		idealSpherical.y = Mathf.Atan2(
		                               position.z - target.position.z,
		                               position.x - target.position.x
		                               );
		
		// calculate the camera's ideal position in world-space
		Vector3 idealPos = target.position +
			SphericalToCartesian(idealSpherical);
		
		// calculate the spring acceleration toward this ideal position
		Vector3 displace = position-idealPos;
		Vector3 springAccel = (displace *-springK)-(cameraVelocity*dampingK);
		
		// Use Euler integration to update camera's volocity and posiotion;
		cameraVelocity += springAccel*time;
		position += cameraVelocity*time;
		transform.position = position;
		
		transform.LookAt(target.position);
		
	}
	/**
     * Converts position in spherical coordinates (lat/lon/altitude)
     * to cartesian (XYZ) coordinates.
     *
     * @param latitude  Latitude in decimal degrees
     * @param longitude Longitude in decimal degrees
     * @param radius    Radius
     * @return the corresponding Point
     */
    public static Vector3 SphericalToCartesian(Vector3 sp) {
		float latitude = sp.x; 
		float longitude = sp.y;
		float radius = sp.z;
        latitude *= Mathf.PI / 180.0f;
        longitude *= Mathf.PI / 180.0f;
		
        float radCosLat = radius * Mathf.Cos(latitude);

        return new Vector3(
                radCosLat * Mathf.Sin(longitude),
                radius * Mathf.Sin(latitude),
                radCosLat * Mathf.Cos(longitude));
    }

    /**
     * Converts position in cartesian coordinates (XYZ)
     * to spherical (radius, lat, lon) coordinates.
     *
     * @param x X coordinate
     * @param y Y coordinate
     * @param z Z coordinate
     * @return a Vec4 for the spherical coordinates {radius, lat, lon}
     */
    public static Vector3 CartesianToSpherical(float x, float y, float z) {
        float rho = Mathf.Sqrt(x * x + y * y + z * z);
        float longitude = Mathf.Atan2(x, z);
        float latitude = Mathf.Asin(y / rho);

        return new Vector3(rho, latitude, longitude);
    }
	
	
	private Vector3 SphericalToCartesial(ref Vector3 vector){
		return Vector3.zero;
	}
}
