using System;
using System.Collections.Generic;
using UnityEngine;

// defines the interface but is not superclass (due to performance)
public class Spline
{
	protected List<Vector3> nodes = new List<Vector3>();
	
	protected Spline ()
	{
	}
	
			
	/**
	 * If last node does not have any time set, assume uniform time distribution from 0 - 1
	 */
	/*public void build(){
		if (nodes[nodes.Count-1].time==0){
			float fraction = 1.0f/(nodes.Count-1);
			for (int i=0;i<nodes.Count;i++){
				ControlPoint p = nodes[i];
				p.time = fraction*i;
				nodes[i] = p;
			}
		}
		solve();
	}*/
	
	public Vector3 GetPosition(float time){
	/*	if (nodes.Count==1){
			return nodes[0].position;
		}
		int i =0;
		// find two nodes to interpolate between
		for (;i<nodes.Count-2;i++){
			if (time<nodes[i+1].time){
				break;
			}
		}
		float t0 = nodes[i].time;
		float t1 = nodes[i+1].time;
		float u = (time-t0)/(t1-t0);
		
		return nodes[i].position*(1-u)+nodes[i+1].position*u; */
		return Vector3.zero;
	}
		
	public float[] getRenderPoints(){
		int subDivisions = 5;
		float[] f = new float[(nodes.Count-1)*subDivisions+1];
		/*
		// iterate each segment
		for (int i=0;i<nodes.Count-1;i++){
			float s1 = nodes[i].time;
			float s2 = nodes[i+1].time;
			float d = s2-s1;
			for (int j=0;j<subDivisions;j++){
				float fraction = 1f/(subDivisions+1);
				f[i*subDivisions+j] = s1+fraction*j*d;
			}
		}
		// set last node
		f[f.Length-1] = nodes[nodes.Count-1].time; */
		return f;
	}
	
	
}